垃圾回收
如上文所述自动寻找是否一些内存“不再需要”的问题是无法判定的。因此，垃圾回收实现只能有限制的解决一般问题。本节将解释必要的概念，了解主要的垃圾回收算法和它们的局限性。

引用

垃圾回收算法主要依赖于引用的概念。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个Javascript对象具有对它 原型 的引用（隐式引用）和对它属性的引用（显式引用）。

在这里，“对象”的概念不仅特指Javascript对象，还包括函数作用域（或者全局词法作用域）。

引用计数垃圾收集

这是最简单的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。

例如

var o = { 
  a: {
    b:2
  }
}; 
// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o
// 很显然，没有一个可以被垃圾收集


var o2 = o; // o2变量是第二个对“这个对象”的引用
o = 1; // 现在，“这个对象”的原始引用o被o2替换了

var oa = o2.a; // 引用“这个对象”的a属性
// 现在，“这个对象”有两个引用了，一个是o2，一个是oa

o2 = "yo"; // 最初的对象现在已经是零引用了
// 他可以被垃圾回收了
// 然而它的属性a的对象还在被oa引用，所以还不能回收

oa = null; // a属性的那个对象现在也是零引用了
// 它可以被垃圾回收了
限制：循环引用

这个简单的算法有一个限制，就是如果一个对象引用另一个（形成了循环引用），他们可能“不再需要”了，但是他们不会被回收。

function f(){
  var o = {};
  var o2 = {};
  o.a = o2; // o 引用 o2
  o2.a = o; // o2 引用 o

  return "azerty";
}

f();
// 两个对象被创建，并互相引用，形成了一个循环
// 他们被调用之后不会离开函数作用域
// 所以他们已经没有用了，可以被回收了
// 然而，引用计数算法考虑到他们互相都有至少一次引用，所以他们不会被回收
实际当中的例子

IE 6, 7 对DOM对象进行引用计数回收。对他们来说，一个常见问题就是内存泄露：

var div = document.createElement("div");
div.onclick = function(){
  doSomething();
}; 
// div有了一个引用指向事件处理属性onclick
// 事件处理也有一个对div的引用可以在函数作用域中被访问到
// 这个循环引用会导致两个对象都不会被垃圾回收


标记-清除算法

这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。

这个算法假定设置一个叫做根的对象（在Javascript里，根是全局对象）。定期的，垃圾回收器将从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和所有不能获得的对象。

这个算法比前一个要好，因为“有零引用的对象”总是不可获得的，但是相反却不一定，参考“循环引用”。

从2012年起，所有现代浏览器都使用了标记-清除垃圾回收算法。所有对JavaScript垃圾回收算法的改进都是基于标记-清除算法的改进，并没有改进标记-清除算法本身和它对“对象是否不再需要”的简化定义。

循环引用不再是问题了

在上面的示例中，函数调用返回之后，两个对象从全局对象出发无法获取。因此，他们将会被垃圾回收器回收。
第二个示例同样，一旦 div 和其事件处理无法从根获取到，他们将会被垃圾回收器回收


内存分析的常用术语，如果有java或者.Net变成经验也许你会更熟悉它们。
对象大小 Object Sizes
保留路径 
Dominators（统治者，我觉得就是父节点的意思）
一个对象A的统治者是从跟节点到A对象的每个简单路径上的对象。也就是，如果统治者对象从堆中移除，对象A到GC根节点将不可达，被抛弃。
统治者对象构成了一个树型结构，因为每个节点有确定的一个统治者。每个对象的统治者缺少直接到达其他对象的路径，也就是，统治者树不是一个生成树。
像Collection集合对象在它们支配其他对象的时候会保留大量内存。这种树节点被称为积累点。

具体细节
这部分介绍V8 JavaScript虚拟机。阅读这部分有助于堆快照的理解。

JavaScript Objects Representation
Number可以用31位整型值（被称为small integers或者SMIs），或者堆对象（被称为heap numbers）。后者用于不适合用SMI格式存储的值，比如double，或者值需要被boxed，比如为它设置属性。

String型既可以被存储在VM堆，又可以存储在浏览器内存中。从web接收内容，没有复制到VM堆中，而是创建一个被包装的对象，被用来和其他存储通信。

当2个String合在一起，它们的内容最初是分开存储的，只是逻辑上合并，通过一个称为cons string的对象实现。只在需要的时候才会合并cons string的内容，比如创建一个需要加入字符的子字符串。

Array在 V8 VM广泛使用，用于存储大量的数据。键值对通过Array备份。因此，数组是JavaScript对象的基本构建块。一个典型的JavaScript对象具有2个数组：一个用来存储属性名称，另一个存储数字元素。当属性的数量非常小的情况下，可在内部存储为JavaScript对象本身。

一个Map对象描述对象的类型和它的布局。例如地图是用来描述隐式对象的层次结构，如下所述：
对象组 Object Groups
每个本地对象组是由互相引用的对象组成。例如，一个DOM子树，每个节点都有一个父链接，链接到下一个孩子节点或者兄弟节点，从而形成一个联通图。需要注意的是本机对象不在JavaScript堆——这就是为什么他们的大小为零。相反，创建wrapper objects。每个包装对象持有响应本地对象的引用，用来重定向对这个包装对象的命令。一个租对象包含包装对象。然而，这并不会创建一个无法回收的周期，GC足够聪明到释放那些不再被组对象引用的包装对象。但忘记释放一个单一的包装对象会保留整个组和相关的包装。