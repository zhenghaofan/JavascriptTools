JavaScript的正则表达式用RegExp对象表示
RegExp.test(目标字符串)返回布尔值
RegExp.exec(目标字符串)匹配时返回一个数组，不匹配返回null
var s = '_x_x';
var r1 = /x/;
r1.exec(s) // ["x"]
如果正则表示式包含圆括号（即要求“组匹配”），则返回的数组会包括多个元素。其中，第一个元素是整个匹配成功的结果，后面的元素就是圆括号对应的匹配成功的组。也就是说，第二个元素对应第一个括号，第三个元素对应第二个括号，以此类推。整个返回数组的length属性等于匹配成功的组数+1。

var s = '_x_x';
var r = /_(x)/;

r.exec(s) // ["_x", "x"]

exec方法的返回数组还包含以下两个属性：

input：整个原字符串。
index：整个模式匹配成功的开始位置（从0开始）。

var r = /a(b+)a/;
var arr = regex.exec("_abbba_aba_");

arr // ["abbba", "bbb"]

arr.index // 1
arr.input // "_abbba_aba_"

字符串对象中的方法：
match()：返回匹配的子字符串。匹配总是从字符串的第一个字符开始
如果正则表达式带有g修饰符，则该方法与正则对象的exec方法行为不同，会一次性返回所有匹配成功的结果。

var s = "abba";
var r = /a/g;

s.match(r) // ["a", "a"]
r.exec(s) // ["a"]

正则表达式的括号表示分组匹配，括号中的模式可以用来捕获分组的内容。

var m = "abcabc".match(/(.)b(.)/);
m
// ["abc", "a", "c"]
上面代码中，正则表达式/(.)b(.)/一共使用两个括号，第一个括号捕获a，第二个括号捕获c。

search()：按照给定的正则表达式进行搜索。
String.search(RegExp);

replace()：按照给定的正则表达式进行替换。
replace方法的一个应用，就是消除字符串首尾两端的空格。

var str = '  #id div.class  ';

str.replace(/^\s+|\s+$/g, '')// "#id div.class"

replace方法的第二个参数可以使用美元符号$，用来指代所替换的内容。

$& 指代匹配的子字符串。
$` 指代匹配结果前面的文本。
$' 指代匹配结果后面的文本。
$n 指代匹配成功的第n组内容，n是从1的自然数。
$$ 指代美元符号$。
"hello world".replace(/(\w+)\s(\w+)/,"$2 $1")// "world hello"

"abc".replace("b", "[$`-$&-$']")// "a[a-b-c]c"

replace方法的第二个参数还可以是一个函数，将匹配内容替换为函数返回值。

"3 and 5".replace(/[0-9]+/g, function(match){
  return 2 * match; })
// "6 and 10"

split()：按照给定规则进行字符串分割。
'a,  b,c, d'.split(',')
// [ 'a', '  b', 'c', ' d' ]

'a,  b,c, d'.split(/, */)
// [ 'a', 'b', 'c', 'd' ]

'a,  b,c, d'.split(/, */, 2)
[ 'a', 'b' ]
上面代码使用正则表达式，去除了子字符串的逗号后面的空格。

转义字符：
\t 制表符   \n 换行符   \r 回车符  
\s 空白符  \S 非空白字符的字符
\w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。
\W 除所有字母、数字和下划线以外的字符，相当于/[^A-Za-z0-9_]/ 。
\d 任意数字 等于[0-9]  \D 任意非数字
使用[]匹配中括号中的任意一个字符 方括号内^表示否定字符
.表示出换行符和其他终止符之外的任意字符
\b 匹配词的边界。
\B 匹配非词边界，即在词的内部。

重复次数字符：
{n,m} 匹配前一项至少n次，至多m次
{n,}  匹配前一项至少n次 
{n} 匹配前一项n次
? 匹配前一项0次或一次
+ 匹配前一项1次或多次
* 匹配前一项0次或多次

非贪婪模式的匹配：/a+?/

/^test$/.test("test test") // false   仅匹配"test"

如果方括号内的第一个字符是[^]，则表示除了字符类之中的字符，其他字符都可以匹配。比如，[^xyz] 表示除了x、y、z之外都可以匹配。如果方括号内没有其他字符，即只有[^]，就表示匹配一切字符，其中包括换行符，而点号（.）是不包括换行符的。

[1-31]不代表1到31，只代表1到3。字符类的连字符必须在头尾两个字符中间，才有特殊含义，否则就是字面含义。比如，[-9]就表示匹配连字符和9，而不是匹配0到9。

在正则表达式内部，可以用\n引用括号匹配的内容，n是从1开始的自然数，表示对应顺序的括号。

/(.)b(.)\1b\2/.test("abcabc")

var tagName = /<([^>]+)>[^<]*<\/\1>/;//匹配html内容
tagName.exec("<b>bold</b>")[1]
// 'b'
             
(?:x)称为非捕获组（Non-capturing group），表示不返回该组匹配的内容，即匹配的结果中不计入这个括号。
var m = "abc".match(/(?:.)b(.)/);
m[1]// "c"



x(?=y)称为先行断言（Positive look-ahead），x只有在y前面才匹配，y不会被计入返回结果。

var m = "abc".match(/b(?=c)/);
m
// "b"
上面的代码使用了先行断言，b在c前面所以被匹配，但是括号对应的c不会被返回。


x(?!y)称为后行断言（Negative look-ahead），x只有不在y前面才匹配，y不会被计入返回结果。

var m = "abd".match(/b(?!c)/);
m
// ["b"]
上面的代码使用了后行断言，b不在c前面所以被匹配，而且括号对应的d不会被返回。
