第一个JavaScript引擎由布兰登·艾克在网景公司开发，用于Netscape Navigator网页浏览器中。引擎的名字叫做SpiderMonkey蜘蛛猴，由C++实现。它自JavaScript 1.5升级以符合ECMA-262版本3。

Mozilla

SpiderMonkey，第一款JavaScript引擎，由Brendan Eich在Netscape Communications时编写，用于Mozilla Firefox 1.0～3.0版本。

Rhino，由Mozilla基金会管理，开放源代码，完全以Java编写。
TraceMonkey，基于实时编译的引擎，其中部份代码取自Tamarin引擎，用于Mozilla Firefox 3.5～3.6版本。
JaegerMonkey，德文J&auml;ger原意为猎人，结合追踪和组合码技术大幅提高性能，部分技术借凿了V8、JavaScriptCore、WebKit，用于Mozilla Firefox 4.0以上版本。

微软
Chakra (JScript引擎)，中文译名为查克拉，用于Internet Explorer 9的32位版本。

Google
V8，开放源代码，由Google丹麦开发，是Chrome浏览器的一部分。
V8在运行之前将JavaScript编译成了机器码，而非字节码或是解释执行它，以此提升性能。更进一步，使用了如内联缓存（inline caching）等方法来提高性能。有了这些功能，JavaScript程序与V8引擎的速度媲美二进制编译

JavaScript解释器通常可以包含四个组成部分：

词法分析器（Lexical Analyser）
句法解析器（Syntax Parser）
字节码生成器（Bytecode generator）
字节码解释器（Bytecode interpreter）

词法分析器
词法分析器的作用，是将一行行的源码拆解成一个个词义单位（token）。所谓“词义单位”，指的是语法上不可能再分的、最小的单个字符或字符组合。

首先，词法分析器会扫描（scanning）代码，提取词义单位；然后，会进行评估（evaluating），判断词义单位属于哪一类的值。

var sum = 30;

// 词法分析后的结果
[
  "var" : "keyword",
  "sum" : "identifier",
  "="   : "assignment",
  "30"  : "integer",
  ";"   : "eos" (end of statement)
]
上面代码中，源代码经过词法分析后，返回一组词义单位，以及它们各自的词类。

句法解析器
句法解析器的作用，是将上一步生成的数组，根据语法规则，转为抽象语法树（Abstract Syntax Tree，简称AST）。
如果源码符合语法规则，这一步就会顺利完成，生成一个抽象语法树；如果源码存在语法错误，这一步就会终止，抛出一个“语法错误”。

{
  operation: "=",
  left: {
    keyword: "var",
    right: "sum"
  }
  right: "30"
}
上面代码中，抽象语法树的一个节点是赋值操作符（=），它两侧的词义单位，分别成左侧子节点和右侧子节>点。

通常，这一步是整个JavaScript代码执行过程中最慢的。

字节码生成器
字节码生成器的作用，是将抽象语法树转为JavaScript引擎可以执行的二进制代码。目前，还没有统一的JavaScript字节码的格式标准，每种JavaScript引擎都有自己的字节码格式。最简单的做法，就是将语义单位翻成对应的二进制命令。

字节码解释器
字节码解释器的作用是读取并执行字节码。


js的引擎是单线程执行的，也就是说在js的进程时间线中同一时间只有一个线程在执行，
关于线程：
每个正在系统上运行的程序都是一个进程。每个进程包含一到多个线程。
进程也可能是整个程序或者是部分程序的动态执行。
线程是一组指令的集合，或者是程序的特殊段，它可以在程序里独立执行。也可以把它理解为代码运行的上下文。所以线程基本上是轻量级的进程，它负责在单个程序里执行多任务。通常由操作系统负责多个线程的调度和执行。
线程是程序中一个单一的顺序控制流程.在单个程序中同时运行多个线程完成不同的工作,称为多线程.

线程和进程的区别在于,子进程和父进程有不同的代码和数据空间,而多个线程则共享数据空间,每个线程有自己的执行堆栈和程序计数器为其执行上下文.多线程主要是为了节约CPU时间,发挥利用,根据具体情况而定. 线程的运行中需要使用计算机的内存资源和CPU。

优点编辑
·使用线程可以把占据时间长的程序中的任务放到后台去处理
·用户界面可以更加吸引人，这样比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度
·程序的运行速度可能加快
·在一些等待的任务实现上如用户输入、文件读写和网络收发数据等，线程就比较有用了。在这种情况下可以释放一些珍贵的资源如内存占用等等。
.多线程技术在IOS软件开发中也有举足轻重的位置。
.线程应用的好处还有很多，就不一一说明了

缺点编辑
·如果有大量的线程,会影响性能,因为操作系统需要在它们之间切换。
·更多的线程需要更多的内存空间。
·线程可能会给程序带来更多“bug”，因此要小心使用。
·线程的中止需要考虑其对程序运行的影响。
·通常块模型数据是在多个线程间共享的，需要防止线程死锁情况的发生。
[2]
一些线程模型的背景
可以重点讨论一下在Win32环境中常用的一些模型。
·单线程模型
在这种线程模型中，一个进程中只能有一个线程，剩下的进程必须等待当前的线程执行完。这种模型的缺点在于系统完成一个很小的任务都必须占用很长的时间。

·多线程块模型（自由线程块模型）
多线程块模型（MTA）在每个进程里只有一个块而不是多个块。这单个块控制着多个线程而不是单个线程。这里不需要消息队列，因为所有的线程都是相同的块的一个部分，并且可以共享。这样的程序比单线程模型和STA的执行速度都要快，因为降低了系统的负载，因而可以优化来减少系统idle的时间。这些应用程序一般比较复杂，因为程序员必须提供线程同步以保证线程不会并发的请求相同的资源，因而导致竞争情况的发生。这里有必要提供一个锁机制。但是这样也许会导致系统死锁的发生。

进程和线程都是操作系统的概念。
进程是应用程序的执行实例，每个进程是由私有的虚拟地址空间、代码、数据和其它各种系统资源组成，进程在运行过程中创建的资源随着进程的终止而被销毁，所使用的系统资源在进程终止时被释放或关闭。
线程是进程内部的一个执行单元。系统创建好进程后，实际上就启动执行了该进程的主执行线程，主执行线程以函数地址形式，比如说main或WinMain函数，将程序的启动点提供给Windows系统。主执行线程终止了，进程也就随之终止。
每一个进程至少有一个主执行线程，它无需由用户去主动创建，是由系统自动创建的。用户根据需要在应用程序中创建其它线程，多个线程并发地运行于同一个进程中。一个进程中的所有线程都在该进程的虚拟地址空间中，共同使用这些虚拟地址空间、全局变量和系统资源，所以线程间的通讯非常方便，多线程技术的应用也较为广泛。多线程可以实现并行处理，避免了某项任务长时间占用CPU时间。要说明的一点是，到2015年为止，大多数的计算机都是单处理器（CPU）的，为了运行所有这些线程，操作系统为每个独立线程安排一些CPU时间，操作系统以轮换方式向线程提供时间片，这就给人一种假象，好象这些线程都在同时运行。由此可见，如果两个非常活跃的线程为了抢夺对CPU的控制权，在线程切换时会消耗很多的CPU资源，反而会降低系统的性能。这一点在多线程编程时应该注意。C++ 11 标准中，STL类库也实现了多线程的类std::thread，使得多线程编程更加方便。

单线程的那么js中是怎么实现onclick、onload、onreadstatechange、setTimeOut等事件的，答案就是浏览器提供。请看下面关于浏览器内核的图：

浏览器把js执行引擎做为浏览器内核里面的一个线程，
当用户在浏览器单击，如果我们添加了onclick时间，那么浏览器帮助我们侦听了这个事件，因为我们(o代表DOM或者BOM对象)o.onclick=function(){}；指定对o对象执行onclick时候(即用户点击页面中的元素)，浏览器事件触发线程会为我们把指定的事件处理程序添加到js引擎当中。···········细心的人会想，就这样完了么？？？

其实，还涉及到比较复杂的过程，就是js的进程时间线，把指定的事件处理程序（如刚刚的function(){}这代码），实际上我们单击页面中的元素对象（此例子中的o），相当于这样子o.onclick()调用，调用的代码就是执行的那段(function(){.....z这里面的代码······})；然后点击o，其实只是把这段代码添加到了js的代码队列里面，其实可能还没有执行。当js进程时间线为空闲的时候，这段代码才会真正的执行。

关于js的进程时间线，我特意画了下面这个图，希望有助于各位理解：



注：handleClick()为我们指定的onclick()事件处理程序代码

从而我们可以得出一个结论：js事件处理机制是异步的，即添加进代码队列里面的时刻与代码实际执行时间可能存在一定时间差。

其实，返观定时器、HTTP异步，其实也就是这么一种处理的模式。


先看下两个例子
1.简单的settimeout：
setTimeout(function () { while (true) { } }, 1000);
setTimeout(function () { alert('end 2'); }, 2000);
setTimeout(function () { alert('end 1'); }, 100);
alert('end');

　　执行的结果是弹出’end’、’end 1’，然后浏览器假死，就是不弹出‘end 2’。也就是说第一个settimeout里执行的时候是一个死循环，这个直接导致了理论上比它晚一秒执行的第二个settimeout里的函数被阻塞，这个和我们平时所理解的异步函数多线程互不干扰是不符的。

附计时器使用方法

--初始化一个简单的js的计时器，一段时间后，才触发并执行回调函数。 setTimeout 返回一个唯一id,可用这个id来取消这个计时器。
var id = setTimeout(fn,delay);

--类似于setTimeout,不一样的是，每隔一段时间，会持续调用回调fn，直到被取消
var id = setInterval(fn,delay);

--传入一个计时器的id,取消计时器。
clearInterval(id);
clearTimeout(id);

①JavaScript引擎是单线程运行的,浏览器无论在什么时候都只且只有一个线程在运行JavaScript程序.

②    JavaScript引擎用单线程运行也是有意义的,单线程不必理会线程同步这些复杂的问题,问题得到简化。



js引擎实现原理：

　　在了解计时器内部运作前，我们必须清楚一点，触发和执行并不是同一概念，计时器的回调函数一定会在指定delay的时间后被触发，但并不一定立即执行，可能需要等待。所有JavaScript代码是在一个线程里执行的，像鼠标点击和计时器之类的事件只有在JS单线程空闲时才执行。

　　我们来看一下图表，一开始你可能并没发现什么或啥都不懂，但请静下心来，在脑海里绘制出这个场景



　　这个图表中有许多数据信息等着我们去理解，当你完全理解了这个图，你会对js的异步运行机制（即JavaScript引擎如何实现异步事件）有很好的了解。这个图是一维的，垂直线上是以毫秒计位，蓝色块代表被划分的不同的js区域执行代码。例如，第一个JS区块执行了18毫秒，鼠标点击事件被阻塞了将近11毫秒，等等。

　　由于JavaScript引擎同一时间只执行一段代码（这是由JavaScript单线程的性质决定的），所以每个JS代码块阻塞了其它异步事件的进行。这意味着当一个异步事件（像鼠标点击、计时器、Ajax）发生时，这些事件的回调函数将排在队列后面等待执行（如何排队完全取决于各浏览器，而我们可以忽视它们内部差异，作一个简化处理）。

　　我们首先从第一个JS代码块开始，有两个计时器被初始化：一个10ms的setTimeout和一个10ms的setInterval.观察计时器初始化位置，（计时器初始化完毕后就会开始计时），发现setTimeout计时器的回调实际上会在第一个代码块执行完毕前被触发。但是这里注意的是，它不会立即执行（单线程不能这样做）。实际上，触发的回调将被排成一个队列，等待下一个可执行时间。

　　此外，在第一个JS代码块，我们发现一个鼠标点击事件被触发。这个鼠标点击JS回调被绑定在异步队列上（我们从来不知道用户什么时候执行这个操作，所以它被认为是异步的）且不能马上执行。像初始化的计时器一样,排队等待执行。

　　执行完初始化JS代码块后，浏览器就有个疑问：谁在等待执行？此时，鼠标点击回调和setTimeout计时器的回调都在等待。浏览器将选一个（鼠标点击事件）并立马执行。而计时器的回调将等待下一合适时机执行。

　　注意，鼠标点击事件执行过程中，interval的回调第一次被触发，与setTimeout的回调一样，排队等待执行。随着时间推移，等到setTimeout计时器的回调执行时候，setInterval的回调再次被触发，这次被触发的回调将被抛弃。如果一大段代码块正在执行，所有的setInterval的回调都将要排队，一旦大段代码块执行完毕，这些一连串的setInterval的回调相互间将被无延迟地执行。实际上，浏览器处理setInterval被触发的回调排队等待执行时，除非队列中setInterval回调为空，才允许新的setInterval的回调加入。

　　我们发现，setInterval的第一个被触发的回调执行时，setInterval的回调又被触发且排到队列。这向我们传达一个重要的消息：setInterval不关心目前JS正在执行的内容，setInterval的被触发的回调都将会无差别地排队。

　　最后，当setInterval的回调执行两次后，我们发现没有javascript引擎要执行东西。这意味着浏览器将等待着一个新的异步事件发生。我们知道，在50ms时候，setInterval的回调再次被触发，但这次并没有东西阻塞，所以回调就立马执行了。

　　在浏览器中，JavaScript引擎是基于事件驱动的，这里的事件可看作是浏览器派给它的各种任务，这些任务可能源自当前执行的代码块，如调用setTimeout()，也可能来自浏览器内核，如onload()、onclick()、onmouseover()、setTimeOut()、setInterval()、Ajax等。如果从代码的角度来看，所谓的任务实体就是各种回调函数，由于“单线程”的原因，这些任务会进行排队，一个接着一个等待着被引擎处理。(这段说法来源于http://www.benben.cc/blog/?p=327)

3.       JavaScript引擎线程和其它侦听线程


上图中，定时器和事件都按时触发了，这表明JavaScript引擎的线程和计时器触发线程、事件触发线程是三个单独的线程，即使JavaScript引擎的线程被阻塞，其它两个触发线程都在运行。

　　浏览器内核实现允许多个线程异步执行，这些线程在内核制控下相互配合以保持同步。假如某一浏览器内核的实现至少有三个常驻线程： JavaScript引擎线程,事件触发线程，Http请求线程，
下面通过一个图来阐明单线程的JavaScript引擎与另外那些线程是怎样互动通信的。
虽然每个浏览器内核实现细节不同,但这其中的调用原理都是大同小异。

     线程间通信：JavaScript引擎执行当前的代码块,其它诸如setTimeout给JS引擎添加一个任务,也可来自浏览器内核的其它线程,如界面元素鼠标点击事件,定时触发器时间到达通知,异步请求状态变更通知等.从代码角度看来任务实体就是各种回调函数,JavaScript引擎一直等待着任务队列中任务的到来.由于单线程关系,这些任务得进行排队,一个接着一个被引擎处理.

GUI渲染也是在引擎线程中执行的，脚本中执行对界面进行更新操作,如添加结点,删除结点或改变结点的外观等更新并不会立即体现出来,这些操作将保存在一个队列中,待JavaScript引擎空闲时才有机会渲染出来。来看例子（这块内容还有待验证,个人觉得当Dom渲染时，才可阻止渲染）

<div id="test">test</div>
<script type="text/javascript" language="javascript">
var i=0;
while(1) {
    document.getElementById("test").innerHTML+=i++ + "<br />";
}
</script>
　　这段代码的本意是从0开始顺序显示数字，它们将一个接一个出现，现在我们来仔细研究一下代码，while(1)创建了一个无休止的循环，但是对于单线程的JavaScript引擎而言，在实际情况中就会造成浏览器暂停响应并处于假死状态。

　　alert()会停止JS引擎的执行，直到按确认键，在JS调试的时候，查看当前实时页面的内容。

4.       setTimeout和 setInterval
回到文章开头，我们来看下setTimeout和setsetInterval的区别。

setTimeout(function(){

    /* Some long block of code ... */

    setTimout(arguments.callee,10);

},10);



setInterval(function(){

    /* Some long block of code ... */

},10);
//需要清空

　　这两个程序段第一眼看上去是一样的，但并不是这样。setTimeout代码至少每隔10ms以上才执行一次；然而setInterval固定每隔10ms将尝试执行，不管它的回调函数的执行状态。

我们来总结下：

l JavaScript引擎只有一个线程，强制异步事件排队等待执行。

l setTimeout和setInterval在异步执行时，有着根本性不同。

l 如果一个计时器被阻塞执行，它将会延迟，直到下一个可执行点（这可能比期望的时间更长）

l setInterval的回调可能被不停的执行，中间没间隔（如果回调执行的时间超过预定等待的值）

《JavaScript高级程序设计》中，针对setInterval说法如下：

当使用setInterval()时，仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中。还要注意两问题：

①    某些间隔会被跳过（抛弃）；

② 多个定时器的代码执行之间的间隔可能会比预期小。此时可采取 setTimeout和setsetInterval的区别 的例子方法。



5.       Ajax异步
　　很多同学朋友搞不清楚，既然说JavaScript是单线程运行的，那么XMLHttpRequest在连接后是否真的异步？其实请求确实是异步的，不过这请求是由浏览器新开一个线程请求(参见上图)，当请求的状态变更时，如果先前已设置回调，这异步线程就产生状态变更事件放到JavaScript引擎的处理队列中等待处理，当任务被处理时，JavaScript引擎始终是单线程运行回调函数，具体点即还是单线程运行onreadystatechange所设置的函数。

　　Tip:理解JavaScript引擎运作非常重要，特别是在大量异步事件（连续）发生时，可以提升程序代码的效率。


GUI渲染线程负责渲染浏览器界面，当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时,该线程就会执行。但需要注意 GUI渲染线程与JS引擎是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。3.
事件触发线程，当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。这些事件可来自JavaScript引擎当前执行的代码块如setTimeOut、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于JS的单线程关系所有这些事件都得排队等待JS引擎处理。（当线程中没有执行任何同步代码的前提下才会执行异步代码）

JavaScript引擎关注着消息队列（不止一个）。它不停地从消息队列中取出消息，并执行这个消息对应的函数（学名“回调函数”）。直到当前函数执行完毕后（以函数栈清空为标准），才继续从队列中取出消息。这样的机制叫做“事件循环（Event Loop）”。那么啥时候会给消息队列添加消息呢？最常见的例子是浏览器触发一个事件（比如click事件）时，若该事件有被绑定一个事件处理函数，则向消息队列添加消息（未有事件处理函数则丢弃该消息）。其实，你编写的全部JS代码，可以视为一个“被首先加入消息队列而被首先执行”的消息（这就是题主我所谓的“同步代码”）。

更复杂的是，消息是有分类别的，按照性质，划分为两大类：macrotask和microtaskmacrotasks: script(你的全部JS代码，“同步代码”）, setTimeout, setInterval, setImmediate, I/O, UI renderingmicrotasks: process.nextTick,Promises, Object.observe, MutationObserver也就是说，js引擎把所有的任务分到两个队列中，一个是macrotask queue（也叫task queue）,另外一个是microtask queue.js引擎首先从macrotask queue中取出第一个任务，执行完毕后，将microtask
queue中的所有任务取出，按顺序全部执行；然后再从macrotask queue中取下一个，执行完毕后，再次将microtask
queue中的全部取出；循环往复，直到两个queue中的任务都取完。


虽然JS运行在浏览器中，是单线程的，但浏览器不是单线程的。浏览器中很多异步行为都是由浏览器新开一个线程去完成。
浏览器内核实现允许多个线程异步执行，这些线程在内核制控下相互配合以保持同步。假如某一浏览器内核的实现至少有三个常驻线程： JavaScript引擎线程,事件触发线程，Http请求线程，
javascript引擎线程是浏览器多个线程中的一个，它本身是单线程的。浏览器还包括很多其他线程，如界面渲染线程，浏览器事件触发线程，Http请求线程等。所以，所谓的javascript是单线程的，是指javascript运行在浏览器中是单线程的，叫做javascript引擎线程。

就是说你这样写setTimeout(fn, 500)并不代表fn肯定在500毫秒之后马上就执行，延迟很可能会更长。因为 JavaScript 是单线程语言，所有的异步事件（包括计时器、鼠标事件或者一个 XMLHttpRequest 完成）仅仅当程序执行期间有缺口的时候才会执行，不是你规定了什么时候就什么时候执行，要知道程序员不是万能的，你写的东西最终还是要看浏览器脸色的。
浏览器内核实现允许多个线程异步执行,这些线程在内核制控下相互配合以保持同步.假如某一浏览器内核的实现至少有三个常驻线 程:javascript引擎线程,界面渲染线程,浏览器事件触发线程,除些以外,也有一些执行完就终止的线程,如Http请求线程,这些异步线程都会产 生不同的异步事件,
