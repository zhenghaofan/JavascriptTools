Vue与React:

React 和 Vue 有许多相似之处，它们都有：

* 使用 Virtual DOM
* 提供了响应式 (Reactive) 和组件化 (Composable) 的视图组件。
* 将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库

追踪数据变化时，react开发可能需要编程人员在组件中定义purecomponent或shouldcomponentupdate的方法，以此追踪组件是否需要被重新渲染；而Vue是自动追踪组件的依赖，系统知道哪个组件需要被重新渲染；

React中一切都是JavaScript，组件模板需要使用jsx语言，而vue则不需要一定使用jsx，可以使用原生HTML作为模板

社区方面React要比Vue强大很多

MVVM:
Model：就是业务逻辑相关的数据对象，是与数据库对应的model。

View：是展现出来的用户界面。

ViewModel: 给view里面的各种控件也定义一个对应的数据对象，这样，只要修改这个数据对象，view里面显示的内容就自动跟着刷新，而在view 里做了任何操作，这个数据对象也跟着自动更新，这样多美。ViewModel的职责就是把model对象封装成可以显示和接受输入的界面数据对象。

简单的说，ViewModel就是View与Model的连接器，View与Model通过ViewModel实现双向绑定。

View绑定到ViewModel，通过view对外暴露出公共属性，然后执行一些命令在向它请求一个动作。而反过来，ViewModel跟Model通讯，告诉它更新来响应UI。这样便使得为应用构建UI非常的容易。往一个应用程序上贴一个界面越容易


Vue核心：

1.MVVM框架，双向绑定，在数据修改的时候能够自动更新视图，这一特性依赖于Object.defineProperty,Vue通过设定对象的setter,getter方法来监听数据的变化，

通过getter进行依赖收集，setter则在数据变更的时候通知订阅者（watcher），根据diff算法来决定是否更新视图(每个组件实例都有相应的 watcher 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新)

2.虚拟DOM：
浏览器在渲染网页时，会先将HTML文档解析并构建DOM树，然后与CSSOM树生成RenderObject树，最后渲染成页面。浏览器中渲染引擎和JavaScript引擎是分离的，渲染引擎会提供一些接口给JavaScript调用，它们二者通信的性能其实是很差的。用脚本进行DOM操作的代价很昂贵，所以要尽量减少用脚本操作DOM的次数，主要运用了虚拟DOM的技术，它创造了虚拟dom并且将它们储存起来，每当状态发生变化的时候就会创造新的虚拟节点和以前的进行对比，让变化的部分进行渲染。
之前，为了优化性能大家通常采用的办法是减少DOM操作次数。而React提出了一个新的思路就是虚拟DOM：组件的HTML结构不再是直接生成DOM，而是映射生成虚拟的JavaScript DOM结构，React通过diff算法将最小变更写入DOM中，从而减少DOM的实际次数，提升性能


Vue.js将DOM抽象成一个以JavaScript对象为节点的虚拟DOM树，以VNode节点模拟真实DOM，可以对这颗抽象树进行创建节点、删除节点以及修改节点等操作，在这过程中都不需要操作真实DOM，只需要操作JavaScript对象后只对差异修改，相对于整块的innerHTML的粗暴式修改，大大提升了性能。修改以后经过diff算法得出一些需要修改的最小单位，再将这些小单位的视图进行更新。这样做减少了很多不需要的DOM操作，大大提高了性能。

Vue就使用了这样的抽象节点VNode，它是对真实DOM的一层抽象，而不依赖某个平台，它可以是浏览器平台，也可以是weex，甚至是node平台也可以对这样一棵抽象DOM树进行创建删除修改等操作，这也为前后端同构提供了可能。

keep-alive:
keep-alive是Vue.js的一个内置组件。它能够不活动的组件实例保存在内存中，而不是直接将其销毁，它是一个抽象组件，不会被渲染到真实DOM中

Vuex：
Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化；它可以应用于多个组件共享同一状态的时候或者不同组件的行为需要触发同一状态
背后的思想是一种单向数据流的思想，vuex维护一个state树，当state发生改变时，组件也会发生改变，组件通过dispatch一个action去触发变化，一旦action commit之后（提交了一个mutation），
state数中的数据就会发生改变，也就导致了组件的重新渲染
